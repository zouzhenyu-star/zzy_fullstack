算法中占最大比例的动态规划
建立感性认识， 具象去学习 ，抽象不好学习
- 爬楼梯
  一阶或二阶 不同的方法到顶

  n阶
  1阶或二阶  不同的方法到顶
  2 2 种
  3 3 f(1) + f(2)

  
  自顶向下问题， 划分为子问题来解决的话， 树状架构， 请使用递归
  两个关键特征
    1. 要求你给出达成某个目的的解法个数
    2. 不要求你给出每种算法对应的具体路径

    1. 定位到问题的终点  n阶台阶的终点
    2. 站在这个终点， 去考虑之前要做什么

    选择树状结构（自上而下）
    f(n) = f(n-1) + f(n+1)

    递归的概念
      1. 问题细化后解决方式类似， 以树状结构自顶向下设计， 找到递归公式
      2. 要有退出条件
      3. 需要优化

    - 向上向下去解决的时候， 就是动态规划  
      站在已知的角度上，通过已知和未知之间的关系， 一步一步的向前推导
      求出未知的值

      读题 正常的想法   DP  最简单的 DP
      n=1  n=2

      n=3 3
      n=4 5
      ..n ?  1 -> n
      n=1 n=2 i=3 , n  公式也很明确 f(n) = f(n-1) + f(n-2)

      - 动态规划是递归的下一站
        1. 自上而下
        2. 发现公式 ， 基于递归， 来找到规律
          状态转移公式
        之所以我们会放弃使用动态规划 ， 选择递归来解决， 是因为有些状态转移不明显


  
        不同面额的 coins 和 一个总金额
        const = [1,2,5]   amount = 11
        所需的最小硬币个数
        动态？ 动态思考解决的方式  最佳方式
        如果是求最值问题， 一般都是用 DP 来解决问题， 先自下而上， 再从自上而下找规律

        自顶向下思考一下
        11  有多少种最少的硬币数组合
        上一次有多少钱
        6  f(n-c5) +1  9 10  公式

        Math.min(f(n-c5) + 1) , f(n-c2) + 1, f(n-c1) +1